% !TEX root = ./root.tex

%A
\tindex{abduction}{앱덕}
\tindex{abduction}{원인 짐작하기}
%\tindex{abduction}{귀추(歸推)}
\tindex{abstract interpretation}{요약해석}
\tindex{abstract semantics}{요약된 의미구조}
\tindex{abstract semantics}{요약 의미}
\tindex{abstract syntax}{핵심 문법구조}
\tindex{abstract type}{구현된 속사정이 감추어진 타입}
\tindex{abstract type}{속내용이 감추어진 타입}
\tindex{abstract class}{껍데기 클래스}
\tindex{abstract class}{클래스 껍데기}
\tindex{abstract method}{껍데기 함수}
\tindex{abstract method}{함수 껍데기}
\tindex{abstract class}{허물 클래스}
\tindex{abstract class}{클래스 허물}
\tindex{abstract method}{허물 함수}
\tindex{abstract method}{함수 허물}
\tindex{abstraction}{요약}
\tindex{abstraction}{속내용 감추기}
\tindex{abstraction}{핵심 드러내기}
\tindex{allocation}{메모리 할당}
\tindex{abstraction hierarchy}{속내용 감추며 차곡차곡 쌓기}
\tindex{application}{호출}
\tindex{application}{사용}
\tindex{applicative language}{값 중심의 언어}
\tindex{assignment}{메모리에 쓰기}
\tindex{assignment}{값 기록하기}
\tindex{assignment}{기록하기}
\tindex{associativity}{방향성}
\tindex{associativity}{결합법칙}
\tindex{attribute grammar}{할일이 딸려있는 문법}
\tindex{attribute grammar}{속성 문법}
\tindex{axiomatic thoery}{엄밀한 논리 시스템}

%B
\tindex{binary}{두개의}
\tindex{bind}{묶다}
\tindex{bind}{이름짓다}
\tindex{bind}{정의하다}
\tindex{binding}{명명하기}
\tindex{binding}{이름짓기}
\tindex{binding}{정의하기}
\tindex{Boolean expression}{부울식}
\tindex{bounded probabilistic polynomial}{오류율을 잡아둘 수 있는 확률형 다항}
\tindex{bounded quantification}{한정해서 일반화시키기}
\tindex{bottom}{바닥}
\tindex{built-in}{붙박이}
\tindex{built-in}{이미 있는}
\tindex{bottom-up program synthesis}{작은 식 조립해서 큰 프로그램 합성하기}

%C
\tindex{calculus}{계산법}
\tindex{calculus}{셈법}
\tindex{call by name}{식전달 호출}
\tindex{call by reference}{주소전달 호출}
\tindex{call by value}{값전달 호출}
\tindex{Cartesian product}{데카르트 곱}
\tindex{Cartesian product}{완전곱}
\tindex{case expression}{선택식}
\tindex{closure conversion}{함수 변환}
\tindex{closure conversion}{함수의 자유변수를 없애주는 변환}
\tindex{closure conversion}{함수가 인자를 통해서만 외부와 소통하게 하는 변환}
\tindex{compilation unit}{컴파일 단위}
\tindex{compilation unit}{번역 단위}
\tindex{compilation}{언어의 기계어 변환}
\tindex{compilation}{프로그램 번역 }
\tindex{complete}{완전한}
\tindex{complete}{빠뜨림이 없는}
\tindex{complete}{빠뜨린게 없는}
\tindex{completeness}{완전성}
\tindex{completeness}{완전함}
\tindex{completeness}{빠뜨림없슴}
\tindex{complete partial-order set}{완전한 부분순서 집합}
\tindex{computation strategy}{계산 방식}
\tindex{computation strategy}{계산 전략}
\tindex{computation}{계산}
\tindex{computational complexity}{계산 복잡도}
\tindex{computational learning theory}{계산 학습 이론}
\tindex{conjunction}{그리고-식}
\tindex{conjunctive normal form}{그리고-조합 바른 식}
\tindex{conjunctive normal form}{그리고-조합 표준형}
\tindex{convex programming}{볼록 프로그래밍}
\tindex{concrete syntax}{구체적 문법 구조}
\tindex{consistency}{일관성}
\tindex{constant}{상수}
\tindex{constraint expression}{제약식}
\tindex{constraint}{제약}
%\tindex{constructive type}{생성적인 타입}
\tindex{constructor bind}{데이타 구성자 정의}
\tindex{constructor description}{데이타 구성자 접속방안}
\tindex{constructor}{데이타 구성자}
\tindex{context}{문맥}
\tindex{context}{환경}
\tindex{continuation}{앞으로 할 일}
\tindex{continuation}{앞으로 할 계산}
\tindex{continuation passing style}{계산과정을 전달하는}
\tindex{continuation passing style}{앞으로 할 일을 전달하는}
\tindex{continuation passing style}{앞으로 할 일을 함수로 정리해서 전달하는}
\tindex{continuation passing style transform}{앞으로 할 일 전달 변환}
\tindex{control flow analysis}{함수 흐름 분석}
\tindex{control flow analysis}{실행 흐름 분석}
\tindex{control structure}{실행 흐름}
\tindex{convergent}{수렴하는}
\tindex{correctness}{올바름}
\tindex{correctness}{맞음}
\tindex{curried application}{함수를 야금야금 적용하기}
\tindex{curried application}{여러인자를 줄세워 전달하기}
\tindex{curried application}{커리형 함수 적용}
\tindex{curried function}{커리형 함수}
\tindex{curried function}{야금야금 함수}
\tindex{curried function}{여러인자를 야금야금 받는 함수}
\tindex{curried function}{여러인자를 줄세워 받는 함수}

%D
\tindex{dangling pointer}{헛 포인터}
\tindex{dangling pointer}{오리알 포인터}
\tindex{dangling pointer}{대상이 사라진 포인터}
\tindex{dangling pointer}{오염된 메모리}
\tindex{dangling pointer}{재활용된 메모리}
\tindex{data constructor}{데이타 구성자}
\tindex{data constructor}{자료 구성자}
\tindex{data description}{데이타 타입 접속방안}
\tindex{data structure}{데이타 구조}
\tindex{data structure}{자료 구조}
\tindex{de-sugar}{설탕 구조를 풀다}
\tindex{de-sugar}{설탕구조를 녹이다}
\tindex{dead code}{무용지물 코드}
\tindex{dead code}{쓸데없는 코드}
\tindex{decision problem}{예-아니오 문제}
\tindex{decision procedure}{예-아니오 판정 알고리즘}
\tindex{decision procedure}{예-아니오 판정 프로그램}
\tindex{declaration}{선언}
\tindex{deduction}{디덕}
\tindex{deduction}{반드시 이끌기}
%\tindex{deduction}{연역(演繹)}
\tindex{deep neural net}{깊은 신경망}
\tindex{deep neural net}{딥뉴럴넷}
\tindex{delayed evaluation}{미루어 계산하기}
\tindex{delayed evaluation}{값 계산을 최대한 미루기}
\tindex{denotational semanitcs}{고정점 방식의 의미구조}
\tindex{denotational semanitcs}{조립식 의미구조}
\tindex{denotational semanitcs}{궁극의 의미하는 바를 표현하는 의미구조}
\tindex{destructive}{저장값을 변동시키는}
\tindex{destructive}{메모리값을 변동시키는}
\tindex{determinisitc}{모든게 정해진}
\tindex{determinisitc}{한가지로 정해진}
\tindex{determinisitc}{계산이 한가지로 확실한}
\tindex{determinisitc}{계산이 하나로 확실한}
\tindex{digit}{숫자}
\tindex{disjunction}{또는-식}
\tindex{disjunctive normal form}{또는-조합 바른식}
\tindex{disjunctive normal form}{또는-조합 표준형}
\tindex{dynamic dispatch}{동적 함수호출}
\tindex{dynamic dispatch}{호출할 함수가 실행중에 결정되는}
\tindex{dynamic scoping}{이름의 유효범위가 실행 중에 결정되는}
\tindex{dynamic scoping}{실행중에 드러나는 이름의 실체}
\tindex{dynamic scoping}{동적으로 유효범위 정하기}
\tindex{dynamic semantics}{동적 의미구조}
\tindex{dynamic semantics}{프로그램의 실행}
\tindex{dynamic semantics}{프로그램의 실행 의미구조}

%E
\tindex{eager evaluation}{적극적인 계산법}
\tindex{eager evaluation}{부지런한 계산법}
\tindex{eager evaluation}{적극적인 계산}
\tindex{eager evaluation}{부지런한 계산}
\tindex{environment}{환경}
\tindex{environment}{이름표 목록}
\tindex{environment}{이름의 실체를 보여주는 목록}
%\tindex{environment enrichment}{기획 환경의 적응}
%\tindex{environment function}{환경 함수}
\tindex{equational reasoning}{같은것들로 따져가기}
\tindex{equational reasoning}{같은것을 따지기}
\tindex{error}{오류}
%\tindex{evaluation by value}{적극적인 계산법}
\tindex{evaluation strategy}{계산방식}
\tindex{evaluation strategy}{계산법}
\tindex{evaluation}{값계산}
\tindex{evaluation}{실행}
\tindex{evaluation}{계산}
\tindex{exception}{예외상황}
\tindex{exception handling}{예외상황 처리}
\tindex{exception bind}{예외상황 정의}
%\tindex{exception description}{예외상황 접속방안}
\tindex{expression}{식}
\tindex{expression}{계산식}
\tindex{expression}{프로그램식}
\tindex{equality saturation}{동일식 전부 찾아내기}
\tindex{equality saturation}{동일식 모두탐색}
\tindex{equality saturation}{동일식 다모으기}

%F
\tindex{first-class function}{특별하게 취급되지않는 함수}
\tindex{first-order equational logic}{단순 등식논리}
\tindex{foreign language interface}{외부 언어와 연결하는 방법}
\tindex{foreign language interface}{다른 언어로 짜여진 프로그램과 연결하는 방법}
\tindex{free identifier}{묶이지않은 이름}
\tindex{free identifier}{정의안된 이름}
\tindex{free identifier}{실체없는 이름}
\tindex{free identifier}{자유로운 이름}
\tindex{free type name}{묶이지않은 타입이름}
\tindex{free variable}{묶이지않은 변수}
\tindex{free variable}{정의안된 변수}
\tindex{free variable}{실체없는 변수}
\tindex{free variable}{자유로운 변수}
\tindex{free variable}{자유변수}
\tindex{function abstraction}{함수}
\tindex{function abstraction}{함수로 만들기}
\tindex{function abstraction}{함수로 속내용 감추기}
\tindex{function application}{함수 사용}
\tindex{function application}{함수 호출}
\tindex{function argument}{함수의 인자}
\tindex{function expression}{함수식}
\tindex{function}{함수}
\tindex{functional language}{함수형 언어}
\tindex{functional language}{값중심 언어}
\tindex{functional language}{함수중심 언어}
\tindex{functional programming}{함수형 프로그래밍}
\tindex{functional programming}{값 중심의 프로그래밍}
\tindex{functional style}{값 중심 스타일}
\tindex{functional style}{함수 중심 스타일}
\tindex{functional style}{함수형 스타일}
\tindex{functor}{모듈함수}
\tindex{functor}{모듈 만드는 함수}
\tindex{functor signature instantiation}{모듈함수 타입의 실현}
\tindex{fuzzing}{마구잡이 깨기}
\tindex{fuzzing}{마구잡이 sw깨기}

%G
\tindex{garbage collection}{메모리 재활용}
\tindex{grammar}{문법}

%H
\tindex{halting problem}{멈춤문제}
\tindex{heap profiler}{메모리 사용 계측기}
\tindex{heap profiler}{메모리 사용 측량기}
\tindex{hierarchy}{계층구조}
\tindex{hierarchy}{계층구조 형성하기}
\tindex{high-order function}{고차 함수}
\tindex{high-order function}{함수를 주고받는 함수}
\tindex{homomorphic}{생긴구조가 같은}
\tindex{homomorphic}{동형의}
\tindex{homomorphic encryption}{동형암호}
\tindex{homomorphic encryption}{암호문끼리 연산가능한 암호체계}

%I
\tindex{identifier}{이름}
\tindex{identity function}{일없는 함수}
\tindex{imperative language}{메모리 중심의 언어}
\tindex{imperative language}{기계중심의 언어}
\tindex{imperative language}{행동지침형 언어}
\tindex{imperative language}{명령형 언어}
\tindex{incomplete}{불완전한}
\tindex{incomplete}{완전하지않은}
\tindex{incomplete}{빠뜨린게 있는}
\tindex{incompleteness theorem}{불완전성 정리}
\tindex{induction}{인덕}
\tindex{induction}{짐작해서 이끌기}
%\tindex{induction}{귀납(歸納)}
\tindex{infix}{사이끼기}
\tindex{insertion sort}{끼워넣기 정렬}
\tindex{interface}{접속방안}
\tindex{interface}{접속형태}
\tindex{interface}{사용법}
\tindex{interface}{허물}
\tindex{interpretation}{실행}
\tindex{interpreter}{실행기}
\tindex{invariant}{불변성질}
\tindex{invariant}{변함없는 성질}
\tindex{invariant}{꾸준한 성질}
\tindex{isomorphic}{똑같은}
\tindex{iteration}{반복}

%L
\tindex{lattice}{래티스}
\tindex{lazy evaluation}{소극적 계산법}
\tindex{lazy evaluation}{제때 계산법}
\tindex{lazy evaluation}{값 계산을 최대한 미루는}
\tindex{lazy evaluation}{필요한 때만 값을 계산하는}
\tindex{leaf}{말단노드}
\tindex{lexical conventions}{어휘 만드는 방법}
\tindex{lexical scope}{생김새로 결정되는 유효 범위}
\tindex{lexicographic order}{사전적 순서}
\tindex{linear function}{직선 함수}
\tindex{list}{리스트}
\tindex{local definition}{우물안 정의}
\tindex{local definition}{동네 정의}
\tindex{logical relation}{논리 관계}
\tindex{logical relation}{타입구조를 타고 정의되는 관계}
\tindex{logical relation}{타입구조를 타고 조립되는 관계}

%M
\tindex{machine learning}{기계 학습}
\tindex{match}{어울리기}
\tindex{match}{패턴에 맞추기}
\tindex{memory leak}{메모리 누수}
\tindex{memory leak}{메모리 출혈}
\tindex{memory leak}{재활용 놓치기}
\tindex{metalanguage}{언어를 설명하는 언어}
\tindex{module}{모듈}
\tindex{model checking}{모델 체킹}
\tindex{model checking}{모델 검증}
\tindex{model checking}{맞나 확인하기}
\tindex{mono-variant analysis}{다수의 프로그램 흐름을 하나로 요약하는 분석}
\tindex{mono-variant analysis}{다대일 분석} 
\tindex{mutual recursive}{서로 호출하는}
\tindex{mutual recursive}{서로 맞물려서 호출하는}

%N
\tindex{negation}{뒤집기}
\tindex{network}{넷트웍}
\tindex{node}{노드}
\tindex{non-deterministic}{한가지로 정해지지 않은}
\tindex{non-deterministic}{모든가지를 한꺼번에 다하는}
\tindex{non-deterministic}{계산이 모든가지로 퍼지는}
\tindex{non-deterministic}{운에 기대는}
\tindex{non-deterministic polynomial}{운에 기대면 다항시간 안에 풀리는}
\tindex{non-deterministic polynomial}{모든가지를 한꺼번에 다할때 다항시간에 풀리는}
\tindex{non-expansive}{새 메모리를 소모하지않는}
\tindex{normal form}{바른꼴}
\tindex{normal form}{표준형}
\tindex{null dereference}{없는 주소 접근}
\tindex{null dereference}{헛 주소 접근}
\tindex{null}{없는 주소}
\tindex{null}{헛 주소}

%O
\tindex{object}{물건}
\tindex{object-oriented language}{물건중심 언어}
\tindex{operational semantics}{실행과정을 드러내는 의미구조} 
\tindex{operational semantics}{계산과정을 드러내는 의미구조} 
\tindex{operator}{연산자}
\tindex{or-pattern}{무더기 패턴}
\tindex{ordered relation}{순서 관계}
\tindex{overflow}{넘침}
\tindex{method overloading}{여러함수를 같은 이름으로}
\tindex{function overloading}{여러함수를 같은 이름으로}

%P
\tindex{Probably Approximately Correct, PAC}{얼추거의맞기}
\tindex{parameter}{인자}
\tindex{parameterized module}{일반화된 모듈}
\tindex{parity function}{홀짝 함수}
\tindex{partial function}{일부만 정의된 함수}
\tindex{pattern match}{패턴에 맞추기}
\tindex{pattern match}{패턴에 대보기}
\tindex{pattern row}{레코드 패턴}
\tindex{pattern}{패턴}
\tindex{polyvariant analysis}{다형성을 가지는 분석}
\tindex{polyvariant analysis}{다대다 분석}
\tindex{polyvariant analysis}{다수의 프로그램 흐름을 하나이상으로 요약하는 분석} 
\tindex{polymorphic function}{다형 함수}
\tindex{polymorphic function}{인자 타입에 상관없는 함수}
\tindex{polymorphic}{다형의}
\tindex{polymorphic}{여러 모양의}
\tindex{polymorphic}{모양이 다양한}
\tindex{polymorphic}{여러 타입을 가지는}
\tindex{polymorphism}{다형성}
\tindex{subtype polymorphism}{아래타입에 한정되는 다형성}
\tindex{subtype polymorphism}{하위타입에 한정되는 다형성}
\tindex{subtype polymorphism}{아래타입 다형성}
\tindex{subtype polymorphism}{하위타입 다형성}
\tindex{parametric polymorphism}{모든타입 다형성}
\tindex{parametric polymorphism}{모든타입에 열려있는 다형성}
\tindex{ad hoc polymorphism}{가짜 다형성}
\tindex{postfix}{뒤에 붙는}
\tindex{precedence}{우선순위}
\tindex{predicate}{조건식}
\tindex{predicate}{논리식}
\tindex{predicate}{논리조건}
\tindex{predicate abstraction}{조건식 요약}
\tindex{predicate abstraction}{논리식 요약}
\tindex{predicate abstraction}{논리조건의 요약}
\tindex{predicate abstraction}{논리식을 하나의 변수로 요약하기}
\tindex{predicate abstraction}{조건식을 하나의 변수로 요약하기}
\tindex{predicate abstraction}{논리조건을 하나의 변수로 요약하기}
\tindex{predicate logic}{모든-어떤 논리}
\tindex{predicate logic}{술어 논리}
\tindex{prefix}{앞에 붙는}
\tindex{primitive recursive function}{기본적인 재귀함수}
\tindex{primitive recursive function}{원시적인 재귀함수}
\tindex{primitive}{기본}
\tindex{principal type}{가장 일반적인 타입}
\tindex{principal type}{대표 타입}
\tindex{programming language}{프로그래밍 언어}
\tindex{program synthesis}{프로그램 합성}
\tindex{program synthesis}{프로그램 자동생성}


%R
\tindex{ramdomization}{무작위}
\tindex{ramdomized algorithm}{무작위 알고리즘}
\tindex{record}{레코드}
\tindex{recursive primitive definition}{원시적 자기참조 정의}
\tindex{recursive}{자기자신을 부르는}
\tindex{recursive}{자기호출}
\tindex{recursive function}{자기호출함수}
\tindex{recursive function}{재귀함수}
\tindex{recursive function}{자기자신을 부르는 함수}
\tindex{reduction}{계산}
\tindex{reduction}{수행}
\tindex{reduction}{줄이기}
\tindex{refactoring}{코드 정리정돈하기}
\tindex{reference manual}{참고서}
\tindex{reference}{메모리 주소}
\tindex{reasoning}{이치따지기}
\tindex{rewrite}{다시쓰기}
\tindex{rewrite rule}{다시쓰기 규칙}
\tindex{rewrite semantics}{다시쓰기로 정의한 의미구조}

%S
\tindex{scaffolding code}{테스터 코드}
\tindex{scaffolding code}{테스트 발판 코드}
\tindex{scheme}{틀}
\tindex{scope}{유효범위}
\tindex{skolemization}{안전하게 정량자 제거하기}
\tindex{skolemization}{안전한 정량자 제거}
\tindex{semantics}{뜻}
\tindex{semantics}{의미}
\tindex{semantics}{속내용}
\tindex{semantics}{의미구조}
\tindex{separated sum}{출신을 기억하는 합집합}
\tindex{separated sum}{출신기억 합집합}
\tindex{sequence}{나열식}
\tindex{side-effect}{메모리 반응}
\tindex{side-effect}{수반되는 반응}
\tindex{side-effect}{함께오는 반응}
\tindex{side-effect}{따라 일어나는 일}
\tindex{signature bind}{모듈타입 정의}
\tindex{signature instantiation}{모듈 타입의 실현}
\tindex{signature matching}{모듈타입에 대보기}
\tindex{signature matching}{모듈타입에 맞추기}
\tindex{signature}{모듈타입}
\tindex{simple type}{단순 타입}
\tindex{soundness}{안전성}
\tindex{soundness}{안전함}
\tindex{soundness}{올바름}
\tindex{soundness}{믿을만함}
\tindex{sparse data structure}{듬성듬성한 데이타구조}
\tindex{sparse data structure}{거의 빈 데이타구조}
\tindex{sparse vector}{거의 빈 벡터}
\tindex{sparse vector}{듬성듬성한 벡터}
\tindex{specification}{명세}
\tindex{static analysis}{정적분석}
\tindex{static analysis}{정적 프로그램분석}
\tindex{static scope}{정적 유효범위}
\tindex{static scope}{미리 결정된 이름의 유효범위}
\tindex{static scoping}{이름의 유효범위가 미리 결정된}
\tindex{static scoping}{실행전에 결정되는 이름의 실체}
\tindex{static semantics}{프로그램의 기획}
\tindex{static semantics}{정적 의미구조}
\tindex{static semantics}{프로그램의 타입 의미구조}
\tindex{static type}{실행전에 파악된 타입}
\tindex{dynamic type}{실행중에 드러난 타입}
\tindex{statically typed language}{실행전에 타입검사하는 언어}
\tindex{statically typed language}{계산전에 타입검사하는 언어}
\tindex{statically typed language}{미리 타입검사하는 언어}
\tindex{dynamically typed language}{실행중에 타입검사하는 언어}
\tindex{dynamically typed language}{계산중에 타입검사하는 언어}
\tindex{dynamically typed language}{돌때 타입검사하는 언어}
\tindex{gradual typing}{실행전과 실행중 타입검사 섞어하기}
\tindex{subtype}{하위타입}
\tindex{subtype}{아래타입}
\tindex{supertype}{상위타입}
\tindex{supertype}{위타입}
\tindex{strict evaluation}{일단 값을 계산하고 보는}
\tindex{strict evaluation}{적극적 계산법}
\tindex{string}{글자실}
\tindex{string}{문자열}
\tindex{structure}{모듈}
\tindex{structure bind}{모듈 정의}
\tindex{structure description}{모듈 접속방안}
\tindex{structure expression}{모듈식}
\tindex{substitution}{바꿔치기}
\tindex{symbol}{심벌}
\tindex{syntactic constraint}{문법적인 제약}
\tindex{syntactic sugar}{설탕구조}
\tindex{syntax analysis}{문법 구조 분석}
\tindex{syntax}{겉모양}
\tindex{syntax}{생김새}
\tindex{syntax}{문법}
\tindex{syntax}{문법구조}

%T
\tindex{tail recursive}{끝 재귀호출}
\tindex{tail recursive}{마지막에 자기자신을 부르는}
\tindex{tail recursive}{자기 호출이 마지막인}
\tindex{template}{거푸집}
\tindex{term}{식}
\tindex{top declaration}{가장 위의 선언}
\tindex{top-level declaration}{가장 위의 선언}
\tindex{total function}{완전히 정의된 함수}
\tindex{tree}{가지구조}
\tindex{tree}{나무구조}
\tindex{tuple}{짝}
\tindex{type}{타입}
\tindex{kind}{타입의 타입}
\tindex{linear type}{선형 타입}
\tindex{linear type}{일회성인지 추적하는 타입}
\tindex{dependent type}{값을 끼고 정의한 타입}
\tindex{refinement type}{다듬어가는 타입}
\tindex{effect type}{값종류이외의 성질을 추적하는 타입}
\tindex{effect type}{기타성질을 추적하는 타입}
\tindex{type abbreviation}{타입 줄임말}
\tindex{type bind}{타입 정의}
\tindex{type construct}{타입식}
\tindex{type constructor}{타입 구성자}
%\tindex{type description}{타입 접속방안}
\tindex{type expression}{타입식}
\tindex{type inference}{타입유추}
\tindex{type inference}{타입 알아내기}
\tindex{type inference}{타입 유추하기}
\tindex{type scheme instantiation}{타입 틀 적용}
\tindex{type scheme instantiation}{타입 틀 구체화}
\tindex{type instantiation}{타입 틀 적용}
\tindex{type instantiation}{타입 틀 구체화}
\tindex{type realization}{타입 틀 실현}
\tindex{type scheme generalization}{타입 틀로 일반화하기}
\tindex{type scheme generalization}{타입 틀 만들기}
\tindex{type scheme}{타입 틀}
\tindex{type structure}{타입 구조}
\tindex{type variable}{타입 변수}
\tindex{type}{타입}
\tindex{typing rule}{타입 유추 규칙}
\tindex{typing rule}{타입 결정 규칙}
\tindex{top-down program synthesis}{큰 틀을 먼저 정하면서 프로그램 합성하기}

%U
\tindex{unary}{인자가 하나인}
\tindex{uncurrying}{야금야금 함수를 단번 함수로}
\tindex{uncurrying}{언커링}
\tindex{undecidable}{컴퓨터로는 할 수 없는}
\tindex{undecidable}{컴퓨터로는 불가능한}
\tindex{unification}{동일화}
\tindex{unification}{같게 만들기}
\tindex{universal machine}{보편만능 기계}
\tindex{univerally quantified type}{타입변수가 모든 타입으로
  바꿔치기될 수 있는}
\tindex{existentially quantified type}{타입변수가 어떤 타입으로
  바꿔치기될 수 있는}

%V
\tindex{value}{값}
\tindex{value bind}{값 정의}
\tindex{variable}{변수}
\tindex{co-variant}{맞춰 변하기}
\tindex{contra-variant}{거슬러 변하기}
\tindex{bi-variant}{맞춰거슬러 변하기}

%W
\tindex{well-founded}{바닥이 있는}
\tindex{well-founded}{바닥이 갖추어진}
\tindex{well-founded}{올바르게 기초한}
\tindex{well-formed}{제대로 생긴}
\tindex{wild pattern}{임의 패턴}
